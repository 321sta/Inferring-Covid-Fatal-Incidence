# Teamwork：
# s2626102 Jingwen Jiang 40%, Write the main content of the code and Write comments.
# s2752993 Ziyi Ye       30%, Discuss, modify, refine the code and Write comments.
# s2646482 Chengpeng Dai 30%, Discuss, modify, refine the code and Write comments.


## Global purpose
# We aim to use the real daily death counts and model infection duration with a log-normal distribution to 
# simulate the initial infection time (t0) for each individual. The "deconv" function iteratively refines t0 
# by introducing random moves. It evaluates these changes using p_value, a modified Pearson statistic 
# that measures the discrepancy between actual and simulated death counts, to decide whether to accept the change.
# After obtaining a converged t0, we reapply the "deconv" function to quantify uncertainty in the estimated incidence 
# trajectory by assuming the observed death counts are estimates of the expected values of Poisson-distributed variables.
# Finally, we generate a plot showing the estimated incidence trajectory over time, including uncertainty visualization, 
# the observed death counts, and the date of the first UK lockdown.

## Global variable declaration
#  't0' means the infection time for 29442 individual (the only thing you need to iterate )
#  's_i_deaths' means the simulated death day for 29442 individuals
#  'deaths' and 's_deaths' mean the real and simulated deaths number in 310 days respectively
#  'duration' means infection duration from log normal distribution for 29442 individuals

days310 <- function(t,deaths){
# Purpose & Approach:
#   Adjust the length of the deaths vector to 310, corresponding to each day of the year.
#
# Inputs:
#   t: A vector representing the days of the year on which deaths occurred.
#   deaths: A vector containing the number of deaths for each day.
#
# Output:
#   new_deaths: A vector of length 310, where each index represents a day of the year, and the element at each index represents the corresponding number of deaths.
  
  new_deaths<-numeric(310)
  new_deaths[t]=deaths
  return(new_deaths)
}

Pdist<-function(deaths,s_deaths){
# Purpose & Approach:
#   Calculate the goodness of fit between the observed (real) deaths and the simulated deaths using a modified Pearson statistic.
#
# Inputs:
#   deaths: A vector containing the observed death counts per day.
#   s_deaths: A vector containing the death counts per day generated by the model.
#
# Output:
#   p: A modified Pearson statistic that quantifies the difference between the real and simulated death counts.
  
  P <- sum((deaths - s_deaths)^2 / pmax(1, s_deaths)) 
  return(P)
}


deconv<- function(t,deaths,n.rep=100,bs=FALSE,t0=NULL,plotting=TRUE){
# Purpose & Approach:
#   This function uses an iterative process to refine the estimates of individuals' infection times (t0). In each iteration, 
#   a random adjustment is proposed for each individual infection time. The function then recalculates the estimated deaths by adding 
#   the infection-to-death duration (which are randomly sampled in each iteration). The estimated deaths are compared with the real deaths, and if the goodness-of-fit 
#   (P) improves, the new infection times (t0) are updated.
#
# Inputs: 
#   t: A vector of time points corresponding to death data; 
#   deaths: A vector containing the observed number of deaths on each day; 
#   n.rep: The number of iterations to run ; 
#   bs: A logical flag indicating whether to quantify the incidence trajectory's uncertainty;
#   t0: An optional vector of initial infection time for each individual;
#   plotting: A logical flag to enable or disable plotting of results for each iteration.
# 
# Outputs: A list containing 
#   P_values: A vector of goodness-of-fit values (P) for each iteration; 
#   inft: A matrix where each column corresponds to the estimated infection counts per day for each iteration.
#   t0: A vector of the estimated infection times after the final iteration.
 
  deaths <- days310(t,deaths) # First change the length of vector to 310, align with the whole vectors when are in one year
  days=1:80 # Disease duration
  densities <- dlnorm(days, meanlog = 3.152, sdlog = 0.451) # Generate a log-normal distribution
  probabilities <- densities / sum(densities) # Normalize the vector to get probabilities of infection-to-death duration
  n <- 29442 # the number of deaths in first 150 rows
  # If t0 is not supplied, initialize it
  if (is.null(t0)) {
    s_i_death <- sample(rep(90:130, length = n), replace = TRUE)  # Create death days for individuals， and select the peak period within the actual death range to help the iteration speed.
    duration <- sample(days, size = n, replace = TRUE, prob = probabilities)  # Sample infection-to-death duration
    t0 <- s_i_death - duration  # Initial infection time guesses
  }
  # Simulates Poisson data in place of the real deaths data, if bs is TRUE
  if (bs) {
    deaths_sim <- rpois(length(deaths), lambda = deaths) # Simulate deaths data from Poisson distribution
    deaths <- deaths_sim  # Update deaths with the simulated data
  }
  P_values <- numeric(n.rep) # Store p
  inft_matrix <- matrix(0, nrow = 310, ncol = n.rep)  # Store infection counts per day
  # Prepare duration for all iterations
  durations_matrix <- replicate(n.rep, sample(days, size = n, replace = TRUE, prob = probabilities))
  # Prepare random order of indices for all iterations
  indices_matrix <- replicate(n.rep, sample(1:length(t0)))
  # Prepare random moves for all iterations
  # In the early iterations, larger moves are used for faster convergence, while smaller moves are used in the later iterations for fine-tuning.
  moves1 <- replicate(floor(n.rep*0.5), sample(c(-8, -4, -2, -1, 1, 2, 4, 8), size = length(t0), replace = TRUE))
  moves2 <- replicate(floor(n.rep*0.25), sample(c(-4, -2, -1, 1, 2, 4), size = length(t0), replace = TRUE))
  moves3 <- replicate((n.rep-floor(n.rep*0.5)-floor(n.rep*0.25)), sample(c(-2, -1, 1, 2), size = length(t0), replace = TRUE))
  moves_matrix <- cbind(moves1,moves2,moves3)
  for (rep in 1:n.rep){
    duration <- durations_matrix[, rep] # Get a new infection-to-death duration for each iteration
    s_i_deaths<- t0 + duration # Simulate death days for individuals
    s_deaths <- tabulate(s_i_deaths, nbins = 310) # Count the number of deaths per day
    P <-Pdist(deaths,s_deaths) # Calculate the goodness of fit
    # Update t0 and P if P is better under t0 random move
    for (i in indices_matrix[, n.rep]) { 
      # Propose a move for the infection day. 
      move <- moves_matrix[i, rep]
      newinfectionday <- t0[i] + move # Change the individual's new infection day
      olddeathday <-t0[i]+duration[i] # Record the individual's new death day
      newdeathday <- newinfectionday+duration[i] # Also record the individual's old death day
      n_s_deaths <- s_deaths 
      n_s_deaths[newdeathday] <- s_deaths[newdeathday] + 1  # Update deaths count 
      n_s_deaths[olddeathday] <- s_deaths[olddeathday] - 1. # Update deaths count 
      new_P <- Pdist(deaths, n_s_deaths)  # Calculate the new goodness of fit
      if (new_P < P) {  # Accept the move if it improves the fit
        t0[i] <- newinfectionday  # Update t0
        P <- new_P  # Update the current best fit 
        s_deaths <- n_s_deaths # Update s_deaths in this loop temporarily
      }
    }
    # Store the current infections per day based on t0
    inft <- tabulate(t0, nbins = 310)
    inft_matrix[, rep] <- inft  # Restore infection counts per day
    P_values[rep] <- P # Restore the new p
    if (plotting){
      # Plotting the current incidence, real deaths, and simulated deaths
      plot(1:310, inft, type = "l", col = "blue", lwd = 2, ylim = range(c(inft, deaths, s_deaths)),
           xlab = "Days", ylab = "Counts", main = paste("Iteration", rep))
      lines(1:310, deaths, col = "red", lwd = 2, lty = 2) # Real deaths
      lines(1:310, s_deaths, col = "green", lwd = 2, lty = 3) # Simulated deaths
      legend("topright", legend = c("Estimated Incidence", "Real Deaths", "Simulated Deaths"),
             col = c("blue", "red", "green"), lty = c(1, 2, 3), lwd = 2)
    }
  }
    return(list(P_values = P_values, inft = inft_matrix, t0 = t0)) # Return the results as a list
}


#setwd("/Users/jingwenjiang/Library/CloudStorage/OneDrive-个人/SEM1/STATISTICS PROGRAMMING/workshop2")
covid_data <- read.table("engcov.txt", header = TRUE, sep = " ", stringsAsFactors = FALSE)
data <- head(covid_data, 150) # Use only the first 150 rows of data 
result <- deconv(data$julian, data$deaths) # First run it to get converged t0
# Start bootstrap to quantify its uncertainty
B <- 20 # Several bootstrap
boot_results <- list()
for (b in 1:B) {
  boot_results[[b]] <- deconv(data$julian, data$deaths,n.rep=10, bs = TRUE, t0 = result$t0, plotting = FALSE) 
}
# Generate a final plot showing the estimated incidence trajectory over time, including uncertainty visualization, the observed death counts, and the date of the first UK lockdown.
par(mar = c(5, 4, 4, 2))
par(mfrow = c(1, 1))
n_days <- 310 
inft_samples <- sapply(boot_results, function(x) apply(x$inft, 1, mean))  # Collect infection estimates from the bootstrap results
inft_mean <- apply(inft_samples, 1, mean) # Calculate the mean infection trajectory across bootstrap samples
# Calculate 95% confidence intervals for infection trajectory
inft_lower <- apply(inft_samples, 1, function(x) quantile(x, 0.025))  # 2.5% quantile
inft_upper <- apply(inft_samples, 1, function(x) quantile(x, 0.975))  # 97.5% quantile
deaths <- days310(data$julian, data$deaths)
plot(1:n_days, inft_mean, type = "l", ylim = c(0, 2000), col = "blue",xlab = "Days", ylab = "Counts") # Add estimated incidence trajectory
polygon(c(1:n_days, rev(1:n_days)), c(inft_upper, rev(inft_lower)), col = rgb(0, 0, 1, 0.2), border = NA) # Add Uncertainty
lines(1:n_days, deaths, col = "red",lty = 2) # Add the raw death data 
abline(v = 84, col = "black", lwd = 2) # Add the vertical line for the UK lockdown 
legend("topright", legend = c("Estimated Incidence", "95% Confidence Interval", "Raw Death Data", "UK Lockdown (Day 84)"),
       col = c("blue", rgb(0, 0, 1, 0.2), "red", "black"), lty = c(1, 1, 2, 1),lwd = c(1,10,1,2))









